# Heap
![Your connection is in bug trouble](image.png)
## Max-куча
В этой куче значение корневого узла должно быть наибольшим среди всех его
дочерних узлов, то же самое должно быть сделано и для его левого и правого
поддерева.  
Общее количество сравнений, необходимых в максимальной куче, зависит от
высоты дерева. Высота полного двоичного дерева всегда равна **log n**, поэтому
временная сложность также будет равна **O(logn)**.  
## Min-куча
В этой куче значение корневого узла должно быть наименьшим среди всех его
дочерних узлов, то же самое должно быть сделано и для его левого и правого
поддерева.    
Общее количество сравнений, необходимых в минимальной куче, зависит от
высоты дерева. Высота полного двоичного дерева всегда равна **log n**, поэтому
временная сложность также будет равна **O(logn)**.
## Свойства Heap
**Куча обладает следующими свойствами:**  
- *Полное двоичное дерево:* Дерево кучи является полным двоичным деревом, то
есть все уровни дерева полностью заполнены, за исключением, возможно,
последнего уровня, который заполняется слева направо возможно не до конца.
Это свойство обеспечивает эффективное представление дерева с помощью
массива.  

- *Свойство кучи:* Это свойство гарантирует, что минимальный (или максимальный)
элемент всегда находится в корне дерева в соответствии с типом кучи.  
Отношения "родитель-ребенок": Связь между родительским узлом с индексом **i** и
его дочерними узлами задается формулами: левый дочерний узел с индексом **2i+1**
и правый дочерний узел с индексом **2i+2** при индексации номеров узлов на
основе 0.   
Если начинают индексацию с 1 то левый **2i** и правый **2i+1** , если heap полный то в
одном уровне они идут по порядку индекса **k, k+1, k+1, k+3 ...** 

- *Эффективная вставка и удаление:* Операции вставки и удаления в кучевых
деревьях являются эффективными. Новые элементы вставляются в следующую
доступную позицию на крайнем правом нижнем уровне, и свойство кучности
восстанавливается путем сравнения элемента с его родителем и, при
необходимости, замены. Удаление корневого элемента заключается в замене его
последним элементом и спуске в кучу.  
Эффективный доступ к экстремальным элементам: Минимальный или
максимальный элемент всегда находится в корне кучи, что обеспечивает доступ к
нему в режиме постоянного времени.
## Другие свойства
Как и любое другое полное бинарное дерево оно обладает свойством увеличения количества элементов на следующем уровне в 2 раза
то есть на если i уровне m узлов то на следующем i + 1 будет 2*m узлов, то есть это описывается геометрической прогрессией
пусть начальное количесвтво элементов b0 = 1 а i тое bi то bi = b0 * 2^(i) по формуле геометрической прогресии тогда сумма всех количеств и будет n те количество всех элементов, s = b0(2^i-1)/(2 - 1) , s = b0(2^i-1) , s = 2^i - 1 , n = 2^h - 1. Где h - высота дерева
тогда  2^h = n + 1 и наконец h = log2(n+1) - это формула высоты бинарного дерева .
пусть количество всех элементов n то количество элементов на последнем уровне будет (n-1)/2 + 1



К примеру есть задача найти вероятность нахождения максимального элемента в последнем уровне а не других
это будет количество элементов в последнем уровне / кол во всех элементов p = ((n-1)/2+1)/n , но если не учитывать один элемент то примерно p = (n/2)/n = 1/2
## Операции, поддерживаемые кучей  
Операции, поддерживаемые min - кучей и max - кучей, одинаковы. Разница лишь
в том, что min-куча содержит минимальный элемент в корне дерева, а max-куча -
максимальный элемент в корне дерева

## Heapify
Это процесс перестановки элементов для сохранения свойств структуры *heap*.
Это делается, когда определенный узел создает дисбаланс в куче из-за нарушения
некоторых правил в зависимости от типа *heap*.  
 Для балансировки дерева
требуется **O(log N)** операции.  
**Для максимальной кучи (max-heap)** балансировка происходит таким образом, что максимальный элемент является корнем этого двоичного дерева.   
**Для минимальной кучи (min-heap)** балансировка происходит таким образом, что минимальный элемент является корнем этого двоичного дерева.

## Insertion
При вставке нового элемента в heap, поскольку мы добавляем новый элемент в
*heap*, он искажает структуру heap, поэтому необходимо выполнить операцию
*heapify*, чтобы сохранить её.  
Эта операция также занимает время **O(logN)**.

## **Max heap**
Правило для каждой пары родитель - два ребенка в *MAX HEAP*: Оба ребенка
будут меньше родителя.

![Popopop](image-1.png)

*Max heapify* берет элемент на **i** и смотрит какой сын больше левый или правый
потом меняется с ним местами, и так пока он не дойдет до тупика то есть его
индекс будет равен или больше размера массива (еще быстрее - можно просто
проверять левого и правого сына не вышли ли они за пределы и одновременно
искать макс)или пока оба сына не будут меньше него. 

**Max heapify:**
```c++
// Функция для обмена двух элементов
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

// Функция для просеивания элемента дерева вверх для максимальной кучи
void max_heapify(int arr[], int n, int i) {
    int largest = i;         // Инициализация largest как корня
    int left = 2 * i + 1;   // левый = 2*i + 1
    int right = 2 * i + 2;  // правый = 2*i + 2

    // Если левый дочерний элемент больше корня
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // Если правый дочерний элемент больше, чем самый большой на данный момент
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // Если самый большой элемент не корень
    if (largest != i) {
        swap(arr[i], arr[largest]);

        // Рекурсивно просеиваем вверх затронутую подкучу
        max_heapify(arr, n, largest);
    }
}
```

## **Min heap**
Правило для каждой пары родитель - два ребенка *MIN HEAP*: оба ребенка будут
больше родителя


![KBTU KBTU KBTU](image-2.png)

*Min heapify* берет элемент на **i** и смотрит какой сын меньше левый или правый
потом меняется с ним местами, и так пока он не дойдет до тупика то есть его
индекс будет равен или больше размера массива (еще быстрее - можно просто
проверять левого и правого сына не вышли ли они за пределы и одновременно
искать минимальный элемент ) или пока оба сына не будут больше него.  

**Min heapify:**
```c++
// Функция для обмена двух элементов
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

// Функция для просеивания элемента дерева вверх для минимальной кучи
void min_heapify(int arr[], int n, int i) {
    int smallest = i;        // Инициализация smallest как корня
    int left = 2 * i + 1;   // левый = 2*i + 1
    int right = 2 * i + 2;  // правый = 2*i + 2

    // Если левый дочерний элемент меньше корня
    if (left < n && arr[left] < arr[smallest])
        smallest = left;

    // Если правый дочерний элемент меньше, чем наименьший на данный момент
    if (right < n && arr[right] < arr[smallest])
        smallest = right;

    // Если наименьший элемент не корень
    if (smallest != i) {
        swap(arr[i], arr[smallest]);

        // Рекурсивно просеиваем вверх затронутую подкучу
        min_heapify(arr, n, smallest);
    }
}
```


## **Heap sort**
На базе предыдущего кода:
```c++
#include <iostream>
using namespace std;

void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void max_heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr[i], arr[largest]);
        max_heapify(arr, n, largest);
    }
}

void build_max_heap(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        max_heapify(arr, n, i);
    }
}

void max_heap_sort(int arr[], int n) {
    build_max_heap(arr, n);
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        max_heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {4, 10, 3, 5, 1};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Unsorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    max_heap_sort(arr, n);

    cout << "\nSorted array by max heapify: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}
```
Мы начинаем с **n / 2 - 1** так как листьям бинарного дерева *(кучи)*, не имеют
дочерних элементов. Это означает, что они уже удовлетворяют свойству кучи.
Начиная с последнего уровня и двигаясь вверх, мы начинаем с узлов, которые
имеют дочерние элементы.

[Для лучшего понимания](https://youtu.be/2DmK_H7IdTo?si=FhSI7DzOYDbFtZw_)


## Priority queues
*Приоритетная очередь (priority queue)* - это абстрактная структура данных,
которая хранит элементы с ассоциированными с ними приоритетами и
предоставляет эффективное извлечение элемента с наивысшим приоритетом. Это
структура данных, полезная во многих алгоритмах и прикладных областях, где
необходимо управлять элементами в порядке их важности или приоритета.
1. `push(int value, int priority)`: Эта функция предназначена для вставки элемента в
приоритетную очередь. Она принимает два аргумента: `value` - значение
элемента, которое вы хотите добавить в очередь, и `priority` - его приоритет.
Элемент добавляется в очередь как пара "значение" и "приоритет". После вставки
элемента функция `heapifyUp` вызывается для убеждения, что элементы внутри
очереди упорядочены с учетом их приоритетов.
2. `pop()`: Эта функция извлекает элемент с наивысшим приоритетом из
приоритетной очереди. Она возвращает структуру `Element`, которая содержит
значение и приоритет этого элемента. После извлечения элемента из очереди,
функция `heapifyDown` вызывается для пересортировки оставшихся элементов и
убеждения, что наивысший приоритет снова находится в вершине очереди.
3. `heapifyUp(int index)`: Эта функция используется для восстановления свойства
мин-кучи после вставки элемента. Она выполняет "поднимающееся вверх"
пересортировку элементов, сравнивая элемент с его родителем и, если
необходимо, меняя их местами, чтобы восстановить правильный порядок.
4. `heapifyDown(int index)`: Эта функция используется для восстановления свойства
мин-кучи после извлечения элемента. Она выполняет "спускающуюся вниз"
пересортировку элементов, сравнивая элемент с его детьми и, если необходимо,
меняя их местами, чтобы восстановить правильный порядок.



### Почему и в каких случаях нужно использовать `PriorityQueue`:  
Приоритетные очереди полезны, когда вам нужно управлять элементами с учетом
их приоритета или важности. Вот некоторые случаи, когда `PriorityQueue` может
быть полезна:
1. Алгоритмы: Во многих алгоритмах, таких как алгоритм Дейкстры, алгоритмы
поиска пути и алгоритмы сортировки, требуется обработка элементов с учетом их
приоритета.
2. Операционные системы: В операционных системах приоритетные очереди
используются для управления процессами и потоками. Задачи с более высоким
приоритетом обслуживаются раньше.
3. Планирование: В системах управления ресурсами, таких как управление пулами
потоков, обработчиками событий и планирование ресурсов,
приоритетные очереди помогают определить, какие задачи следует обрабатывать
в первую очередь.
4. Прикладные области: Во многих прикладных областях, таких как логистика,
транспорт, распределенные системы и другие, приоритетные очереди
используются для оптимизации и управления процессами.

Все эти случаи требуют эффективного управления элементами с приоритетами, и
приоритетные очереди предоставляют эффективное средство для этой цели.  
Реализация:
```c++
#include <iostream>
#include <vector>

// Структура элемента для хранения значения и его приоритета
struct Element {
    int value;
    int priority;

    Element(int val, int prio) : value(val), priority(prio) {}
};

class PriorityQueue {
private:
    std::vector<Element> heap;

    // Восстановление свойств кучи при добавлении элемента
    void heapifyUp(int index) {
        while (index > 0) {
            int parentIndex = (index - 1) / 2;
            if (heap[parentIndex].priority > heap[index].priority) {
                std::swap(heap[parentIndex], heap[index]);
                index = parentIndex;
            } else {
                break;
            }
        }
    }

    // Восстановление свойств кучи при удалении элемента
    void heapifyDown(int index) {
        int size = heap.size();
        while (true) {
            int leftChild = 2 * index + 1;
            int rightChild = 2 * index + 2;
            int smallest = index;

            if (leftChild < size && heap[leftChild].priority < heap[smallest].priority) {
                smallest = leftChild;
            }

            if (rightChild < size && heap[rightChild].priority < heap[smallest].priority) {
                smallest = rightChild;
            }

            if (smallest != index) {
                std::swap(heap[index], heap[smallest]);
                index = smallest;
            } else {
                break;
            }
        }
    }

public:
    // Добавление элемента в очередь с приоритетами
    void push(int value, int priority) {
        heap.push_back(Element(value, priority));
        heapifyUp(heap.size() - 1);
    }

    // Извлечение элемента с наивысшим приоритетом из очереди
    Element pop() {
        if (empty()) {
            throw std::out_of_range("Priority queue is empty");
        }
        Element top = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
        return top;
    }

    // Проверка пуста ли очередь
    bool empty() const {
        return heap.empty();
    }
};

int main() {
    PriorityQueue pq;
    pq.push(3, 1);
    pq.push(1, 3);
    pq.push(4, 2);
    pq.push(1, 4);
    pq.push(5, 1);

    // Вывод элементов очереди в порядке их приоритета
    while (!pq.empty()) {
        Element top_element = pq.pop();
        std::cout << "Value: " << top_element.value << ", Priority: " << top_element.priority << std::endl;
    }

    return 0;
}
```

1. Внутри класса есть вектор heap, который используется для хранения
элементов с их значениями и приоритетами.
1. Метод push используется для вставки элемента с заданным значением и
приоритетом. Элемент добавляется в вектор, а затем вызывается heapifyUp
для восстановления свойства мин-кучи.
2. Метод pop извлекает элемент с наивысшим приоритетом из начала очереди.
Этот элемент удаляется из вектора, и после этого вызывается heapifyDown,
чтобы восстановить свойство мин-кучи.
3. Метод empty просто проверяет, пуста ли очередь, возвращая true, если она
пуста, и false в противном случае.  

Этот класс позволяет вам управлять элементами с приоритетами и извлекать их в
порядке возрастания приоритета. Вы можете использовать его в различных
ситуациях, где требуется упорядочивание элементов по приоритету, как описано
выше.
1. Приватные члены класса:
- `std::vector<Element> heap;`: Это вектор, который хранит элементы
приоритетной очереди. Каждый элемент представлен структурой `Element`,
содержащей значение и приоритет элемента.
- `void heapifyUp(int index)`: Это приватная функция, используемая для поднятия
элемента вверх в куче после вставки. Она принимает индекс элемента в `heap` и
сравнивает его с его родителем, и, если необходимо, меняет их местами. Затем она
переходит к родителю и продолжает анализ до корня кучи.
- `void heapifyDown(int index)`: Эта приватная функция используется для
опускания элемента вниз в куче после извлечения элемента. Она принимает
индекс элемента и сравнивает его с детьми, заменяя его на наименьший из детей,
если необходимо, и так продолжается до тех пор, пока свойство мин-кучи не
будет восстановлено.
2. Публичные члены класса:
- `void push(int value, int priority)`: Это публичная функция, которую можно
использовать для вставки элемента в приоритетную очередь. Она принимает
значение элемента (`value`) и его приоритет (`priority`) и добавляет их в `heap`.
Затем вызывается `heapifyUp` для восстановления корректного порядка.
- `Element pop()`: Это публичная функция для извлечения элемента с наивысшим
приоритетом из очереди. Возвращает извлеченный элемент вместе с его
значением и приоритетом. После извлечения вызывается `heapifyDown`, чтобы
восстановить свойство мин-кучи.
- `bool empty() const`: Это публичная функция, предназначенная для проверки,
пуста ли приоритетная очередь. Возвращает `true`, если очередь пуста, и `false`,
если в ней есть элементы
