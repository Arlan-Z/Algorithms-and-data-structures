## DFS

“Поиск в глубину” или “обход в глубину” — это рекурсивный алгоритм по поиску всех вершин графа или дерева. Обход подразумевает под собой посещение всех вершин графа.

Алгоритм поиска в глубину
Стандартная реализация поиска в глубину помещает каждую вершину (узел, node) графа в одну из двух категорий:

Пройденные (Visited).

Не пройденные (Not Visited).

Цель алгоритма состоит в том, чтобы пометить каждую вершину как “Пройденная”, избегая при этом циклов.

Алгоритм поиска в глубину работает следующим образом:

Начните с того, что поместите любую вершину графа на вершину стека.

Возьмите верхний элемент стека и добавьте его в список “Пройденных”.

Создайте список смежных вершин для этой вершины. Добавьте те вершины, которых нет в списке “Пройденных”, в верх стека.

Необходимо повторять шаги 2 и 3, пока стек не станет пустым.

Пример реализации поиска в глубину
Предлагаю рассмотреть на примере, как работает алгоритм поиска в глубину. Мы будем использовать неориентированный граф с пятью вершинами.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/751ed3b5-42d2-420d-8059-d643a216ffe0)

Начнем мы с вершины “0”. В первую очередь алгоритм поиска в глубину поместит ее саму в список “Пройденные” (на изображении “Visited”), а ее смежные вершины — в стек.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/849bb09c-2577-4b23-9d78-c19366368daa)

Затем мы берем следующий элемент сверху стека, т.е. к вершину “1”, и переходим к ее соседним вершинам. Поскольку вершина “0” уже пройдена, следующая вершина “2”.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/ed7903a2-68fa-404d-9988-73f08a8b28ef)

Вершина “2” смежна непройденной вершине “4”, следовательно мы добавляем ее наверх стека и проходим ее.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/94b8f819-df1f-45cd-8c6b-7b515b16ea0e)

Вершина “2” смежна непройденной вершине “4”, следовательно мы помещаем ее в верх стека.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/913fc54a-ebcc-4416-8b06-8e3a23c7e173)

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/a1838058-db37-44e0-b17c-d9cdba122e89)

Добавляем вершину “4” в список “Пройденные” после прохождения.

После того, как мы пройдем последний элемент (вершину “3”), в стеке не останется непройденных смежных вершин, и таким образом мы завершили обход графа в глубину.

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/48adad7c-4eae-4d70-a7bd-4f99fe6a188f)

После проверки всех смежных вершин для вершины “3” стек остался пустым, а значит алгоритм обхода графа в глубину завершил свою работу.



Временная сложность (или асимптотическая сложность) обхода в ширину (BFS) в графе зависит от числа вершин V и числа рёбер E. Для неориентированного графа без весов на рёбрах, сложность BFS составляет O(V + E).

Если представить граф в виде матрицы смежности, где V - количество вершин, а E - количество рёбер, то BFS посещает каждую вершину и ребро ровно один раз, что приводит к временной сложности O(V + E).

Если граф представлен списком смежности, где каждая вершина хранит свой список соседей, то время работы BFS также составляет O(V + E), где V - количество вершин, а E - количество рёбер.

Пространственная сложность BFS в худшем случае равна O(V), где V - количество вершин в графе. Это потому, что в худшем случае все вершины могут быть добавлены в очередь одновременно, что приведет к использованию памяти, пропорциональной числу вершин.



## Topological Sort


