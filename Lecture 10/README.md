## Hash tables 

Хэш таблица - это структура данных, которая позволяет быстро и эффективно хранить и получать данные. Основная идея заключается в использовании хэш-функции для преобразования ключей (например, строк или чисел) в индексы, по которым данные будут храниться в массиве.
То есть хэш таблица по каким то параметрам элемента (ключ), через хэш функцию вычисляет его код то есть индекс , по этому временная сложность нахождения элемента в хэш коде будет за константное время в то время как при обычном линейном поиске в массиве уйдет линейное время.

Простое объяснение:

У нас есть массив, который выглядит как большой ящик со множеством ячеек.

Когда мы хотим сохранить данные (например, значение) под определенным ключом, мы применяем хэш-функцию к этому ключу. Хэш-функция генерирует числовое значение (хэш), которое является индексом ячейки в массиве.

Мы помещаем данные в ячейку с этим индексом.

Когда нам нужно получить данные по ключу, мы снова применяем хэш-функцию к ключу, она возвращает индекс, по которому мы ищем данные в массиве. Таким образом, мы быстро находим данные, не проходя по всему массиву.

Важно, чтобы хэш-функция была хорошей, чтобы минимизировать коллизии (ситуации, когда разные ключи имеют одинаковый хэш) и обеспечивать эффективность хеш-таблицы.

Для операций поиска, вставки и удаления хэш-таблицы имеют среднюю временную сложность O(1). Однако в худшем случае эти операции могут потребовать времени O(n), где n - количество элементов в таблице.

В основном используются строки (string) как ключи и через хэш функцию мы преобразуем строку в число 

![image](https://github.com/Arlan-Z/Algorithms-and-data-structures/assets/122739941/89788023-906e-4f31-8fee-83839d0b35f3)

но так как можно использовать любое свойство элемента что отличает его от другого то можно к примеру:
существует класс элемента с полями свойство 1 и свойство 2 
и для каждого элемента то есть объекта этого класса эти свойства будут разными то их можно использовать как ключи

```
class ArrayElement
    integer key
    string value // свойство элемента

function ArrayElementHash(element)
    // Простая хеш-функция: взятие остатка от деления на 10.
    return hash(element.key) % 10



function main()
    // Создаем хеш-таблицу с объектами ArrayElement и хеш-функцией ArrayElementHash
    hashTable = new HashTable(ArrayElement, ArrayElementHash)

    // Создаем объекты ArrayElement
    element1 = new ArrayElement(1, "Value 1")
    element2 = new ArrayElement(2, "Value 2")

    // Вставляем элементы в хеш-таблицу
    hashTable.insert(element1, element1.value)
    hashTable.insert(element2, element2.value)

    // Получаем значение по ключу
    value = hashTable.get(element1)
    print("Значение по ключу 1: " + value)

```

**Проблема коллизии **

Естественно, возникает вопрос, почему невозможно такое, что мы попадем дважды в одну ячейку массива, ведь представить функцию, которая ставит в сравнение каждому элементу совершенно различные натуральные числа просто невозможно. Именно так возникает проблема коллизии, или проблемы, когда хеш-функция выдает одинаковый индекс для разных элементов.

Существует несколько решений данной проблемы:

1. **Метод цепочек (Chaining)**:
   - Каждая ячейка хеш-таблицы содержит связанный список элементов с одинаковыми хешами.
   - При коллизии, элементы просто добавляются в соответствующий связанный список.
   - Этот метод прост и эффективен, но может потребовать дополнительной памяти для хранения связанных списков.

2. **Открытое адресное хеширование (Open Addressing)**:
   - Все элементы хранятся непосредственно в массиве.
   - При коллизии, алгоритм ищет следующую доступную ячейку в массиве.
   - Существует несколько вариантов открытого адресного хеширования, такие как линейное и квадратичное пробирование, двойное хеширование и другие.

3. **Рехеширование (Rehashing)**:
   - При коллизии, можно пересчитать хеш для ключа и попробовать разместить его в другой ячейке.
   - Рехеширование может быть полным (полностью изменяется хеш-функция) или частичным (небольшие изменения хеш-функции).

4. **Линейное пробирование (Linear Probing)**:
   - При коллизии, алгоритм проверяет следующую ячейку в массиве и продолжает двигаться по массиву до тех пор, пока не найдет свободную ячейку.
   - Этот метод может быть подвержен кластеризации (скоплению элементов вблизи друг друга).

5. **Двойное хеширование (Double Hashing)**:
   - При коллизии, алгоритм использует вторую хеш-функцию для вычисления новой ячейки для элемента.
   - Этот метод помогает разрешить коллизии без слияния элементов в одном месте, но требует правильного выбора второй хеш-функции.


**Использование хэш таблицы на cpp где элементы это строки**
```c++
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Создаем хеш-таблицу для хранения строк (ключей) и их значений
    unordered_map<string, string> hashMap;

    // Вставляем элементы в хеш-таблицу
    hashMap["apple"] = "A sweet fruit";
    hashMap["banana"] = "A tropical fruit";
    hashMap["cherry"] = "A small, red fruit";

    // Получаем значения по ключам
    string key = "apple";
    if (hashMap.find(key) != hashMap.end()) {
        cout << "Значение для ключа '" << key << "': " << hashMap[key] << endl;
    } else {
        cout << "Ключ '" << key << "' не найден." << endl;
    }

    key = "grape";
    if (hashMap.find(key) != hashMap.end()) {
        cout << "Значение для ключа '" << key << "': " << hashMap[key] << endl;
    } else {
        cout << "Ключ '" << key << "' не найден." << endl;
    }

    return 0;
}

```
**Хэш таблица написанная без библиотеки**
```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Простая хеш-функция, которая возвращает сумму кодов символов ключа
int simpleHash(const string& key, int tableSize) {
    int hash = 0;
    for (char ch : key) {
        hash += static_cast<int>(ch);
    }
    return hash % tableSize;
}

int main() {
    const int tableSize = 100;
    vector<pair<string, string>> hashTable[tableSize];

    // Вставляем элементы в хеш-таблицу
    hashTable[simpleHash("apple", tableSize)].emplace_back("apple", "A sweet fruit");
    hashTable[simpleHash("banana", tableSize)].emplace_back("banana", "A tropical fruit");
    hashTable[simpleHash("cherry", tableSize)].emplace_back("cherry", "A small, red fruit");

    // Получаем значение по ключу
    string key = "apple";
    int index = simpleHash(key, tableSize);
    string value = "Key not found";

    for (const auto& entry : hashTable[index]) {
        if (entry.first == key) {
            value = entry.second;
            break;
        }
    }

    cout << "Value for 'apple': " << value << endl;

    key = "grape";
    index = simpleHash(key, tableSize);
    value = "Key not found";

    for (const auto& entry : hashTable[index]) {
        if (entry.first == key) {
            value = entry.second;
            break;
        }
    }

    cout << "Value for 'grape': " << value << endl;

    return 0;
}

```

без встроенной функции static_cast<int> :

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Простая хеш-функция, которая возвращает сумму кодов символов ключа
int simpleHash(const string& key, int tableSize) {
    int hash = 0;
    for (char ch : key) {
        hash += ch;
    }
    return hash % tableSize;
}

int main() {
    const int tableSize = 100;
    vector<pair<string, string>> hashTable[tableSize];

    // Вставляем элементы в хеш-таблицу
    hashTable[simpleHash("apple", tableSize)].emplace_back("apple", "A sweet fruit");
    hashTable[simpleHash("banana", tableSize)].emplace_back("banana", "A tropical fruit");
    hashTable[simpleHash("cherry", tableSize)].emplace_back("cherry", "A small, red fruit");

    // Получаем значение по ключу
    string key = "apple";
    int index = simpleHash(key, tableSize);
    string value = "Key not found";

    for (const auto& entry : hashTable[index]) {
        if (entry.first == key) {
            value = entry.second;
            break;
        }
    }

    cout << "Value for 'apple': " << value << endl;

    key = "grape";
    index = simpleHash(key, tableSize);
    value = "Key not found";

    for (const auto& entry : hashTable[index]) {
        if (entry.first == key) {
            value = entry.second;
            break;
        }
    }

    cout << "Value for 'grape': " << value << endl;

    return 0;
}
```

**Хэш функция которая выдает именно индекс в массиве и не превышает его размер**
```c++
int customHash(const string& key, int tableSize) {
    int hash = 0;
    int prime = 31;  // Простое число для улучшения равномерного распределения хешей 

    for (char ch : key) {
        hash = (hash * prime + static_cast<int>(ch)) % tableSize;
    }
    
    return hash;
}
```

без встроенной функции static_cast<int> :

```c++
int customHash(const string& key, int tableSize) {
    int hash = 0;
    int prime = 31;

    for (char ch : key) {
        hash = (hash * prime + ch) % tableSize;
    }
    
    return hash;
}

```

## Хэш функции
**Сумма символов**
Хэш-функция суммы символов (или просто суммарная хэш-функция) - это очень простой способ генерации хеш-значения для строки или последовательности символов. Она работает следующим образом:

1. Входная строка или последовательность символов разбивается на отдельные символы.
2. Затем для каждого символа вычисляется его код символа (например, ASCII-код) или значение Unicode.
3. Полученные коды символов суммируются.
4. Результат суммирования является хеш-значением.

Пример:
Допустим, у нас есть строка "hello". Мы можем использовать хэш-функцию суммы символов для этой строки следующим образом:

1. Разбиваем строку на отдельные символы: "h", "e", "l", "l", "o".
2. Вычисляем коды символов:
   - Код "h" равен, например, 104 (для ASCII).
   - Код "e" равен 101.
   - Код "l" равен 108.
   - Код "o" равен 111.
3. Суммируем коды символов: 104 + 101 + 108 + 108 + 111 = 532.
4. Хеш-значением для строки "hello" с использованием этой хэш-функции будет 532.

Преимущества хэш-функции суммы символов:
- Простота и быстрота вычисления.
- Малое потребление памяти.

Недостатки хэш-функции суммы символов:
- Низкая устойчивость к коллизиям (разным входным строкам могут соответствовать одни и те же хеш-значения).
- Небезопасна для криптографического использования.

Хэш-функция суммы символов подходит для простых задач, где не требуется высокая степень устойчивости к коллизиям, и важна только быстрая проверка целостности данных. Однако в более серьезных приложениях, таких как хранение паролей или проверка цифровых подписей, следует использовать более надежные криптографические хеш-функции.


**Полиномиальная**
Полиномиальная хеш-функция - это один из типов хеш-функций, которые используют многочлены для вычисления хеш-кода ключа (например, строки) путем применения формулы, которая включает коэффициенты многочлена и значения символов ключа.

Примером полиномиальной хеш-функции может быть следующая формула:

```
hash(key) = (a_n * x^n + a_(n-1) * x^(n-1) + ... + a_2 * x^2 + a_1 * x + a_0) % M
```

Где:
- `a_n, a_(n-1), ..., a_1, a_0` - коэффициенты многочлена.
- `x` - некоторое число (часто выбирается простое число).
- `n` - длина ключа.
- `M` - размер хеш-таблицы.

Полиномиальные хеш-функции могут быть полезны для равномерного распределения ключей в хеш-таблице, что помогает уменьшить коллизии. Они используются в различных алгоритмах и структурах данных, таких как хеш-таблицы и строковые таблицы.



```c++
int phash(string s, int x = 2, int q = 100000) {
    int res = 0;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        res += int(s[i]) * pow(x, n - i - 1); // Используем функцию pow для возведения в степень а не ^
    }
    return res % q;
}

int main(){
    string s = "abc";
    cout<<phash(s); // вывел 683
    return 0;
}
```

Более производительная версия с тем же результатом:
так как hash(s) = (s[0]*x^(n-1)+s[1]*x^(n-2)+s[2]*x^(n-3)+.....+s[n-2]*x+s[n-2])%q
это тоже самое что hash = (hash * x + int(s[i])) % q в for(int i=0;i<n;i++);

```c++
int phash(string s, int x=2, int q=100000) {
    int res = 0;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        res = (res * x + int(s[i])) % q;
    }
    return res;
}

int main(){
    string s = "abc";
    cout<<phash(s); // вывел 683
    return 0;
}
```
**Хэш-функция остатка**
Хэш-функция остатка, также известная как деление по модулю, представляет собой простой метод генерации хеш-значения для чисел. Она работает следующим образом:

1. Возьмите входное число (ключ), которое вы хотите хешировать.
2. Выберите фиксированное положительное число, называемое модулем (обычно это целое число, большее 1).
3. Вычислите остаток от деления входного числа на модуль.
4. Остаток от деления будет являться хеш-значением.

Математически это можно записать как: `хеш = ключ % модуль`.

Пример:
Предположим, у нас есть хэш-функция с модулем 10, и мы хотим хешировать несколько чисел. Вот как это работает:

1. Ключ: 42
2. Модуль: 10
3. Хеш = 42 % 10 = 2

Таким образом, хеш-значением для числа 42 с использованием хэш-функции остатка с модулем 10 будет 2.

Еще один пример:

1. Ключ: 123
2. Модуль: 5
3. Хеш = 123 % 5 = 3

Таким образом, хеш-значением для числа 123 с использованием хэш-функции остатка с модулем 5 будет 3.

Преимущества хэш-функции остатка:
- Простота и быстрота вычисления.
- Малое потребление памяти.
- Всегда возвращает целые числа в диапазоне от 0 до (модуль - 1).

Недостатки хэш-функции остатка:
- Низкая устойчивость к коллизиям, особенно если ключи не равномерно распределены.
- Не подходит для строк и других нечисловых данных.

Хэш-функция остатка часто используется в простых хеш-таблицах и алгоритмах хеширования для быстрого поиска и доступа к данным, но её надежность ограничена, и она не подходит для задач, где важна высокая степень устойчивости к коллизиям.


**Хэш функция умножения**
Хэш-функция умножения - это еще один простой метод генерации хеш-значения, который использует умножение входного числа на некоторую константу и извлечение дробной части результата. Этот метод можно описать следующим образом:

1. Возьмите входное число (ключ), которое вы хотите хешировать.
2. Выберите положительное вещественное число между 0 и 1, называемое константой умножения (обычно оно выбирается эмпирически).
3. Умножьте ключ на выбранную константу умножения.
4. Извлеките дробную часть результата.
5. Домножьте дробную часть на некоторое большое число (например, размер таблицы хешей) и округлите до целого числа.
6. Полученное целое число будет являться хеш-значением.

Математически это можно записать как: `хеш = floor(N * (ключ * A - floor(ключ * A)))`, где `ключ` - входное число, `A` - константа умножения, `N` - размер таблицы хешей.

Пример:
Допустим, у нас есть хэш-функция умножения с константой A = 0.6180339887 и размером таблицы хешей N = 100. Мы хотим хешировать число 42. Вот как это работает:

1. Ключ: 42
2. Константа умножения: A = 0.6180339887
3. Результат умножения: 42 * 0.6180339887 ≈ 25.9390169914
4. Извлекаем дробную часть: 0.9390169914
5. Домножаем на N: 0.9390169914 * 100 ≈ 93.90169914
6. Округляем до целого: хеш = floor(93.90169914) = 93

Таким образом, хеш-значением для числа 42 с использованием хэш-функции умножения будет 93.

Преимущества хэш-функции умножения:
- Относительно быстрая и простая в реализации.
- Может обеспечивать более равномерное распределение хеш-значений, чем некоторые другие простые хэш-функции.

Недостатки хэш-функции умножения:
- Низкая устойчивость к коллизиям в сравнении с более сложными криптографическими хеш-функциями.
- Выбор правильной константы умножения может потребовать некоторого экспериментирования.

Хэш-функция умножения может использоваться в простых хеш-таблицах и других алгоритмах хеширования, где не требуется высокая степень защиты от коллизий.


**Хэш-функция XOR**
Хэш-функция XOR (исключающее ИЛИ) - это еще один простой метод генерации хеш-значения. Она работает путем применения операции XOR к битовым представлениям входных данных. Этот метод может быть использован как для хеширования чисел, так и для хеширования байтовых последовательностей, таких как строки. Вот как это работает:

1. Возьмите входное значение, которое вы хотите хешировать, и разбейте его на байты (если это строка, то на символы).
2. Выполните операцию XOR между всеми байтами (или битами) входных данных.
3. Результат этой операции будет хеш-значением.

Пример для чисел:
Предположим, у нас есть числа 42 и 18. Мы хотим использовать хэш-функцию XOR для этих чисел. Вот как это работает:

1. Число 42 в двоичной системе: 00101010
2. Число 18 в двоичной системе: 00010010
3. Выполняем операцию XOR:
   00101010
   00010010
    : : : : 
   00111000

Результат операции XOR для чисел 42 и 18 равен 56. Таким образом, хеш-значением для этих чисел с использованием хэш-функции XOR будет 56.

Пример для строк:
Предположим, у нас есть строки "hello" и "world". Мы хотим использовать хэш-функцию XOR для этих строк. Вот как это работает:

1. Строка "hello" в байтах (ASCII или Unicode): [104, 101, 108, 108, 111]
2. Строка "world" в байтах (ASCII или Unicode): [119, 111, 114, 108, 100]
3. Выполняем операцию XOR по байтам:
   [104, 101, 108, 108, 111]
   [119, 111, 114, 108, 100]
    : : : :  : : : :  : : : : 
   [015, 010, 006, 000, 011]

Результат операции XOR для строк "hello" и "world" будет массивом байтов [15, 10, 6, 0, 11]. Этот массив байтов может рассматриваться как байтовое хеш-значение для строк.

Преимущества хэш-функции XOR:
- Простота и быстрота вычисления.
- Может быть использована как для чисел, так и для строк.

Недостатки хэш-функции XOR:
- Низкая устойчивость к коллизиям, особенно при хешировании строк и других данных.
- Не подходит для криптографических целей из-за недостаточной стойкости к атакам.

Хэш-функция XOR может использоваться в простых хеш-таблицах и алгоритмах хеширования для простых задач, но она не рекомендуется для задач, где требуется высокая степень защиты от коллизий.


**Хэш-функция сдвига**
Хэш-функция сдвига (или битовая хэш-функция) - это метод генерации хеш-значения, который работает путем сдвига битов входных данных и объединения их в одно целое число. Вот как это работает:

1. Возьмите входное значение (число или байтовую последовательность), которое вы хотите хешировать.
2. Разбейте это значение на биты (если это число) или байты (если это последовательность).
3. Выполните логические операции сдвига (левого или правого) над битами (или байтами) входных данных.
4. Объедините сдвинутые биты (или байты) в одно целое число.
5. Полученное целое число будет являться хеш-значением.

Пример для чисел:
Предположим, у нас есть число 42, и мы хотим использовать хэш-функцию сдвига для него. Вот как это работает:

1. Число 42 в двоичной системе: 00101010
2. Выполняем операцию сдвига влево на 2 бита:
   00101010
   : : : : 
   10101000

Результат операции сдвига для числа 42 на 2 бита влево будет 168. Таким образом, хеш-значением для числа 42 с использованием хэш-функции сдвига будет 168.

Пример для строк:
Предположим, у нас есть строка "hello", и мы хотим использовать хэш-функцию сдвига для неё. В этом случае, мы можем сначала представить символы строки в их байтовом виде (например, в кодировке ASCII или UTF-8), а затем выполнить операцию сдвига над байтами, как в предыдущем примере.

Преимущества хэш-функции сдвига:
- Простота и быстрота вычисления.
- Может быть использована как для чисел, так и для строк.

Недостатки хэш-функции сдвига:
- Низкая устойчивость к коллизиям, особенно при хешировании строк и других данных.
- Не подходит для криптографических целей из-за недостаточной стойкости к атакам.

Хэш-функция сдвига может использоваться в простых хеш-таблицах и алгоритмах хеширования для простых задач, но она не рекомендуется для задач, где требуется высокая степень защиты от коллизий.



## Алгоритм поиска под строки 

Алгоритм Рабина-Карпа — это алгоритм поиска подстроки в тексте на основе хеш-функций. Этот алгоритм использует хеширование для быстрого сравнения подстроки и текста. Вот как он работает:

Вычислите хеш (хеш-значение) для исходной строки, которую вы ищете (подстрока) и для первой подстроки того же размера в тексте, который вы анализируете.

Сравните хеш-значения. Если они совпадают, значит, вы нашли потенциальное совпадение.

Если хеш-значения совпадают, проверьте подстроку и соответствующий участок текста посимвольно, чтобы убедиться, что это действительно совпадение.

Если хеш-значения не совпадают, пересчитайте хеш для следующей подстроки текста.

Повторяйте шаги 2-4, пока не найдете все вхождения подстроки в тексте.

Этот алгоритм позволяет ускорить поиск, так как сравнение хеш-значений быстрее, чем посимвольное сравнение всей подстроки. Однако алгоритм требует эффективной функции хеширования и обработки возможных коллизий (когда хеш-значения разные, но сами строки могут быть одинаковыми).

Вот почему Рабин-Карп может быть быстрее:

1. Хеширование: Вместо того, чтобы сравнивать подстроку с текстом посимвольно, Рабин-Карп вычисляет хеш-значение для подстроки и хеш-значения для окон текста (подстроки того же размера). Если хеш-значения совпадают, это указывает на потенциальное совпадение.
2. Сравнение хешей: Сравнивая хеш-значения, Рабин-Карп выполняет сравнение в одной операции, вместо многократных операций сравнения символов в наивном алгоритме. Это может существенно ускорить поиск.
3. Пропуск окон: Если хеш-значения не совпадают, алгоритм Рабина-Карп может легко переместить окно на одну позицию вперед и пересчитать хеш для нового окна. Это снижает количество операций сравнения и сдвига.

Пропуск окон (или сдвиг окна) - это одна из ключевых оптимизаций, которая делает алгоритм Рабина-Карп более эффективным при поиске подстроки в тексте. Эта оптимизация позволяет алгоритму пропускать некоторые проверки и пересчитывать хеш-значение только частично, вместо того, чтобы проверять каждый возможный сдвиг.
1. Начнем с того, что мы сначала вычисляем хеш-значение для первой подстроки в тексте и сравниваем его с хеш-значением подстроки, которую мы ищем.
2. Если хеш-значения совпадают, это указывает на потенциальное совпадение.
3. Если хеш-значения не совпадают, вместо того, чтобы сдвигать окно на один символ и пересчитывать хеш для нового окна снова с нуля, мы используем информацию из предыдущего окна.
4. Мы вычитаем значение, которое "выходит" из окна (символ, который ушел), и добавляем новый символ, который "входит" в окно. Это позволяет пересчитать хеш-значение быстрее, чем полностью заново.
5. Затем мы проверяем снова хеш-значение нового окна. Если оно совпадает с хеш-значением подстроки, это также указывает на потенциальное совпадение.
6. Процесс повторяется, сдвигая окно на одну позицию вперед, пересчитывая хеш и сравнивая хеш-значения, пока не найдем все вхождения подстроки.


Предположим, у нас есть текст "abcdeabcd" и мы ищем подстроку "bcd". Мы хотим использовать алгоритм Рабина-Карп для поиска.

1. Начнем с вычисления хеш-значения подстроки "bcd" и сравниваем его с хеш-значением первых трех символов текста "abc". Пусть хеш-значение подстроки и текста совпадает.

2. Теперь мы начинаем сдвигать окно на один символ вправо. Вместо того, чтобы полностью пересчитывать хеш для нового окна "bcd", мы используем информацию из предыдущего окна.

3. Мы вычитаем значение "a" (символ, который ушел из окна) из хеш-значения предыдущего окна и добавляем новый символ "d" (который входит в окно). Теперь мы имеем новое хеш-значение для окна "bcd".

4. Мы сравниваем это новое хеш-значение с хеш-значением подстроки "bcd". Если они совпадают, это указывает на потенциальное совпадение.

5. Мы продолжаем сдвигать окно, вычитая "b" и добавляя "a", и проверяем хеш-значение для нового окна. Если оно не совпадает, мы снова вычитаем "a" и добавляем "b" и так далее.

6. Процесс повторяется до тех пор, пока окно полностью не покроет все символы в тексте.

Преимущество этого метода заключается в том, что мы пересчитываем хеш-значение только частично, а не полностью для каждого окна. Это позволяет сократить количество вычислений и ускорить поиск подстроки в тексте.



```c++
#include <iostream>
#include <string>

using namespace std;

// Функция для вычисления хеш-значения подстроки
unsigned int hash(const string& str, int start, int length) {
    unsigned int result = 0;
    for (int i = start; i < start + length; i++) {
        result = result * 256 + str[i]; // Простой способ хеширования
    }
    return result;
}

// Функция для поиска всех вхождений подстроки в тексте
void RabinKarpSearch(const string& text, const string& pattern) {
    int textLength = text.length();
    int patternLength = pattern.length();
    unsigned int patternHash = hash(pattern, 0, patternLength); // Хеш-значение подстроки
    unsigned int textHash = hash(text, 0, patternLength); // Хеш-значение первого окна текста

    // Проходимся по всем возможным окнам текста для поиска подстроки
    for (int i = 0; i <= textLength - patternLength; i++) {
        if (textHash == patternHash) {
            // Хеш-значения совпадают, проверяем совпадение символов подстроки и окна
            bool match = true;
            for (int j = 0; j < patternLength; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                cout << "Найдено вхождение на позиции " << i << endl;
            }
        }

        // Сдвиг окна: вычитаем старый символ, который уходит из окна, и добавляем новый символ
        if (i != textLength - patternLength) {
            textHash = (textHash - text[i] * (256 << (patternLength - 1))) * 256 + text[i + patternLength];
        }
    }
}

int main() {
    string text = "abracadabra"; // Текст, в котором ищем подстроку
    string pattern = "cad"; // Подстрока, которую ищем
    RabinKarpSearch(text, pattern); // Запуск алгоритма
    return 0;
}
```

**C использованием Полиномиальной хэш функции:**
при хэш функции: 

h = (s[0]*x^(n-1)+s[1]*x^(n-2)+s[2]*x^(n-3)+.....+s[n-2]*x+s[n-1])%q

тогда сдвинутый хэш будет h = ((s[1]*x^(n-2)+s[2]*x^(n-3)+.....+s[n-2]*x+s[n-1])*x + s[n])%q 

здесь мы вычли первый чар то есть s[0]*x^(n-1) после умножили все на x и добавили новый элемент s[n]

тогда это можно вырозить так h = ((h-s[0]*x^(n-1))*x + s[n])%q

с учетом прошлого кода сдвиг для полиномиальной хэш функции будет по формуле :

textHash=(textHash*x−charAt(i - m + 1)*x^(m−1) +charAt(i + 1))mod q


```c++
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

int phash(const string& s, int start, int length, int x, int q) { // Полиномиальная хэш функция
    int res = 0;
    for (int i = start; i < start + length; i++) {
        res = (res * x + int(s[i])) % q;
    }
    return res;
}

void RabinKarpSearch(const string& text, const string& pattern, int x = 256, int q = 31) {
    int m = pattern.length();
    int n = text.length();

    // Вычисляем хэш для шаблона
    int patternHash = phash(pattern, 0, m, x, q);

    // Вычисляем хэш для первого окна текста
    int textHash = phash(text, 0, m, x, q);

    // Проходим по тексту с использованием сдвига окна
    for (int i = 0; i <= n - m; i++) {
        // Если хэши совпадают, проверяем символы посимвольно
        if (patternHash == textHash) {
            bool match = true;
            for (int j = 0; j < m; j++) { // дополнительная проверка
                if (pattern[j] != text[i + j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                cout << "Pattern found at index " << i << endl;
            }
        }

        //Сдвиг окна: вычитаем старый символ, который уходит из окна, и добавляем новый символ при сдвиге окна в перед появляется один новый
        if (i < n - m) { // условие чтобы хэш не вышел за пределы так как он берет i+m то есть он может выйти за границы
            textHash = ((textHash - int(text[i]) * int(pow(x, m - 1))) * x + int(text[i + m])) % q; // (textHash - int(text[i]) * pow(x, m - 1, q)) * x отнимаем последний элемент в старом оке который исчезает при сдвиге домножая все на x для сдвига в верх и + int(text[i + m]) добавляем новый элемент , который появляется при сдвиге
            if (textHash < 0) {
                textHash += q;
            }
        }
    }
}

int main() {
    string text = "abracadabra"; // Текст, в котором ищем подстроку
    string pattern = "cad"; // Подстрока, которую ищем
    RabinKarpSearch(text, pattern); // Запуск алгоритма
    return 0;
}
```

**Для лучшего понимания**
https://www.youtube.com/watch?v=S-LXeuHGF98

