# Binary search
**Двоичный поиск** - это алгоритм поиска, который работает быстрее, чем алгоритм
линейного поиска. Двоичный поиск используется для поиска позиции целевого
элемента в отсортированном массиве путем многократного деления пространства
поиска пополам. При каждом сравнении бинарный поиск удаляет половину
массива. Его временная сложность составляет **O(log n)**, где **n** - количество элементов в массиве.  
## Как работает бинарный поиск? 

Важно что бинарный поиск работает на любых массивах и интервалах чисел, то
есть не обязательно что поле работы это массив это может быть число то есть мы
можем искать число в каком то промежутке или элемент в массиве. Идея
заключается в сравнении среднего элемента с тем значением которое мы хотим
найти путь это будет целевое значение , если средний элемент равен целевому
значению, то индекс среднего элемента является позицией целевого значения.
Если целевое значение меньше среднего элемента, то целевое значение ищется в
левой половине текущего пространства, а если целевое значение больше среднего
элемента, то целевое значение ищется в правой половине текущего пространства.
Это делается до тех пор, пока не будет найден целевой элемент, если он
присутствует в массиве.  
Среднее может вычисляться 2 способами:
``` c++
int mid = left+ (right–left)/2;
int mid = (left + right)/2;
```
Для того чтобы искать в левой половине то есть от левого до среднего то нужно
сделать правый элемент (предел) средним, но нам не нужно в этом случае
проверять средний элемент так как мы это сделали и ничего не нашли тогда
делаем правый элемент тем элементом что перед средним.  
```c++
right = mid - 1;
```  
Для того чтобы искать в правой половине нужно сделать левый (предел) элемент
средним , лучше тем что после среднего.
```c++
left = mid + 1;  
```
И продолжаем поиск до тех пор пока не найдем элемент или не пройдем весь
массив то есть если левый будет равен правому.  
Mожно называть левые и правые как хотите некоторые называют их **low** и **high**
![Missing](https://media.geeksforgeeks.org/wp-content/uploads/20230711134722/Binary-Search.png "Example")


**Рекурсивная реализация**
```c++
int binarySearch(int arr[], int left, int right, int x) {
    if (right >= left) {
        int mid = (right + left) / 2;
                            // условие остановки рекурсии это нахождение элемента
        if (arr[mid] == x) {
            return mid;
        }
                            // если x меньше среднего ищем в левой части
        if (arr[mid] > x) {
            return binarySearch(arr, left, mid - 1, x);
        } else {            // иначе в правой части
            return binarySearch(arr, mid + 1, right, x);
        }
    }
    return -1;
}

int main(void) {
    int arr[] = { 2, 3, 4, 10, 40 }; // Наш массив
    int x = 10; // Число которое мы ищем
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, x);
    cout << result // Порядковый номер этого числа
    return 0;
}
```
Output
```
3 
```
Временная Сложность: **O(log n)**  
Вспомогательное Пространство: **O(log n)**

**Итеративная реализация**
```c++
#include <bits/stdc++.h>
using namespace std;

int binarySearch(int arr[], int low, int high, int x) {
    while (low <= high) {
        int mid = low + (high - low) / 2; //лучше искать так хз почему
        if (arr[mid] == x) {
            return mid;
        }
        if (arr[mid] < x) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

int main(void) {
    int arr[] = { 2, 3, 4, 10, 40 };
    int x = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, x);
    cout << result;
    return 0;
}
```
Output
```
3 
```
Временная Сложность: **O(log n)**  
Вспомогательное Пространство: **O(1)**